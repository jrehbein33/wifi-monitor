#!/usr/bin/env python3
"""
MÃ³dulo de anÃ¡lisis de vulnerabilidades de red
Analiza dispositivos conectados en busca de vulnerabilidades comunes
"""

import socket
import threading
import time
import subprocess
import json
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import requests

class VulnerabilityAnalyzer:
    def __init__(self):
        """Inicializar el analizador de vulnerabilidades"""
        self.common_ports = {
            21: 'FTP',
            22: 'SSH', 
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            135: 'RPC',
            139: 'NetBIOS',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            993: 'IMAPS',
            995: 'POP3S',
            1433: 'SQL Server',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL',
            5900: 'VNC',
            8080: 'HTTP-Alt'
        }
        
        self.vulnerability_db = {
            21: {
                'service': 'FTP',
                'severity': 'Medium',
                'description': 'FTP transmite credenciales en texto plano',
                'recommendation': 'Usar SFTP o FTPS en su lugar'
            },
            23: {
                'service': 'Telnet',
                'severity': 'High',
                'description': 'Telnet transmite datos sin cifrar',
                'recommendation': 'Migrar a SSH para conexiones seguras'
            },
            135: {
                'service': 'RPC',
                'severity': 'Medium',
                'description': 'RPC puede exponer informaciÃ³n del sistema',
                'recommendation': 'Deshabilitar si no es necesario'
            },
            139: {
                'service': 'NetBIOS',
                'severity': 'Medium', 
                'description': 'NetBIOS puede filtrar informaciÃ³n de red',
                'recommendation': 'Deshabilitar NetBIOS sobre TCP/IP'
            },
            445: {
                'service': 'SMB',
                'severity': 'High',
                'description': 'SMB v1 es vulnerable a ataques remotos',
                'recommendation': 'Actualizar a SMB v2/v3 y aplicar parches'
            },
            3389: {
                'service': 'RDP',
                'severity': 'High',
                'description': 'RDP expuesto puede ser objetivo de ataques',
                'recommendation': 'Usar VPN o restringir acceso por IP'
            },
            5900: {
                'service': 'VNC',
                'severity': 'High',
                'description': 'VNC puede tener autenticaciÃ³n dÃ©bil',
                'recommendation': 'Configurar contraseÃ±as fuertes y tÃºnel SSH'
            }
        }
        
        self.scan_results = {}
        self.vulnerability_report = []
        
    def scan_device_ports(self, ip: str, timeout: float = 1.0) -> Dict[int, str]:
        """Escanear puertos comunes en un dispositivo"""
        open_ports = {}
        
        def scan_port(port: int):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    service = self.common_ports.get(port, 'Unknown')
                    open_ports[port] = service
                sock.close()
            except:
                pass
                
        # Escanear puertos en paralelo
        threads = []
        for port in self.common_ports.keys():
            thread = threading.Thread(target=scan_port, args=(port,))
            threads.append(thread)
            thread.start()
            
        # Esperar a que terminen todos los hilos
        for thread in threads:
            thread.join()
            
        return open_ports
    
    def analyze_device_vulnerabilities(self, ip: str, open_ports: Dict[int, str]) -> List[Dict]:
        """Analizar vulnerabilidades basadas en puertos abiertos"""
        vulnerabilities = []
        
        for port, service in open_ports.items():
            if port in self.vulnerability_db:
                vuln_info = self.vulnerability_db[port].copy()
                vuln_info['device_ip'] = ip
                vuln_info['port'] = port
                vuln_info['timestamp'] = datetime.now().isoformat()
                vulnerabilities.append(vuln_info)
                
        return vulnerabilities
    
    def check_default_credentials(self, ip: str, port: int, service: str) -> Optional[Dict]:
        """Verificar credenciales por defecto comunes"""
        default_creds = {
            'SSH': [('admin', 'admin'), ('root', 'root'), ('admin', 'password')],
            'HTTP': [('admin', 'admin'), ('admin', 'password'), ('admin', '')],
            'Telnet': [('admin', 'admin'), ('admin', 'password')],
            'FTP': [('anonymous', ''), ('ftp', 'ftp'), ('admin', 'admin')]
        }
        
        if service in default_creds:
            # SimulaciÃ³n de verificaciÃ³n de credenciales
            # En un entorno real, esto harÃ­a conexiones reales
            return {
                'vulnerability': 'Default Credentials',
                'severity': 'Critical',
                'description': f'Posibles credenciales por defecto en {service}',
                'recommendation': 'Cambiar credenciales por defecto inmediatamente'
            }
        return None
    
    def get_device_info(self, ip: str) -> Dict:
        """Obtener informaciÃ³n adicional del dispositivo"""
        device_info = {
            'ip': ip,
            'hostname': 'Unknown',
            'os_guess': 'Unknown',
            'mac_address': 'Unknown'
        }
        
        try:
            # Intentar resolver hostname
            hostname = socket.gethostbyaddr(ip)[0]
            device_info['hostname'] = hostname
        except:
            pass
            
        try:
            # Obtener direcciÃ³n MAC usando ARP
            result = subprocess.run(['arp', '-n', ip], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            device_info['mac_address'] = parts[2]
                        break
        except:
            pass
            
        return device_info
    
    def analyze_network_configuration(self) -> List[Dict]:
        """Analizar configuraciÃ³n de red en busca de problemas de seguridad"""
        network_issues = []
        
        try:
            # Verificar configuraciÃ³n WiFi
            result = subprocess.run(['networksetup', '-getairportnetwork', 'en0'], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                network_name = result.stdout.strip().split(': ')[-1]
                
                # Verificar si la red usa WEP (inseguro)
                wifi_info = subprocess.run(['networksetup', '-getairportpower', 'en0'],
                                         capture_output=True, text=True, timeout=5)
                
                # AnÃ¡lisis bÃ¡sico de seguridad WiFi
                if 'WEP' in network_name.upper():
                    network_issues.append({
                        'vulnerability': 'Weak WiFi Encryption',
                        'severity': 'High',
                        'description': 'La red WiFi usa encriptaciÃ³n WEP obsoleta',
                        'recommendation': 'Actualizar a WPA2/WPA3'
                    })
                    
        except Exception as e:
            pass
            
        return network_issues
    
    def scan_network_devices(self, network_devices: List[str]) -> Dict:
        """Escanear todos los dispositivos de la red en busca de vulnerabilidades"""
        print("ğŸ” Iniciando escaneo de vulnerabilidades...")
        
        all_vulnerabilities = []
        device_summaries = {}
        
        for device_ip in network_devices:
            print(f"   Analizando {device_ip}...")
            
            # Escanear puertos
            open_ports = self.scan_device_ports(device_ip)
            
            # Obtener informaciÃ³n del dispositivo
            device_info = self.get_device_info(device_ip)
            
            # Analizar vulnerabilidades
            device_vulns = self.analyze_device_vulnerabilities(device_ip, open_ports)
            
            # Verificar credenciales por defecto
            for port, service in open_ports.items():
                default_cred_vuln = self.check_default_credentials(device_ip, port, service)
                if default_cred_vuln:
                    default_cred_vuln['device_ip'] = device_ip
                    default_cred_vuln['port'] = port
                    default_cred_vuln['service'] = service
                    device_vulns.append(default_cred_vuln)
            
            # Resumen del dispositivo
            device_summaries[device_ip] = {
                'device_info': device_info,
                'open_ports': open_ports,
                'vulnerabilities': device_vulns,
                'risk_score': self.calculate_risk_score(device_vulns)
            }
            
            all_vulnerabilities.extend(device_vulns)
        
        # Analizar configuraciÃ³n de red
        network_vulns = self.analyze_network_configuration()
        all_vulnerabilities.extend(network_vulns)
        
        # Generar reporte final
        report = {
            'scan_timestamp': datetime.now().isoformat(),
            'total_devices': len(network_devices),
            'total_vulnerabilities': len(all_vulnerabilities),
            'device_summaries': device_summaries,
            'network_vulnerabilities': network_vulns,
            'severity_summary': self.get_severity_summary(all_vulnerabilities)
        }
        
        self.vulnerability_report = report
        print(f"âœ… Escaneo completado: {len(all_vulnerabilities)} vulnerabilidades encontradas")
        
        return report
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> int:
        """Calcular puntuaciÃ³n de riesgo basada en vulnerabilidades"""
        score = 0
        severity_points = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }
        
        for vuln in vulnerabilities:
            score += severity_points.get(vuln.get('severity', 'Low'), 1)
            
        return min(score, 100)  # MÃ¡ximo 100 puntos
    
    def get_severity_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """Obtener resumen de severidad de vulnerabilidades"""
        summary = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            if severity in summary:
                summary[severity] += 1
                
        return summary
    
    def get_top_recommendations(self, limit: int = 5) -> List[str]:
        """Obtener las principales recomendaciones de seguridad"""
        if not self.vulnerability_report:
            return []
            
        recommendations = set()
        vulnerabilities = []
        
        # Recopilar todas las vulnerabilidades
        for device_data in self.vulnerability_report.get('device_summaries', {}).values():
            vulnerabilities.extend(device_data.get('vulnerabilities', []))
        vulnerabilities.extend(self.vulnerability_report.get('network_vulnerabilities', []))
        
        # Ordenar por severidad y obtener recomendaciones Ãºnicas
        severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}
        vulnerabilities.sort(key=lambda x: severity_order.get(x.get('severity', 'Low'), 3))
        
        for vuln in vulnerabilities:
            recommendations.add(vuln.get('recommendation', ''))
            if len(recommendations) >= limit:
                break
                
        return list(recommendations)[:limit]