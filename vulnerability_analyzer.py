#!/usr/bin/env python3
"""
Módulo de análisis de vulnerabilidades de red
Analiza dispositivos conectados en busca de vulnerabilidades comunes
"""

import socket
import threading
import time
import subprocess
import json
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import requests

class VulnerabilityAnalyzer:
    def __init__(self):
        """Inicializar el analizador de vulnerabilidades"""
        self.common_ports = {
            21: 'FTP',
            22: 'SSH', 
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            135: 'RPC',
            139: 'NetBIOS',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            993: 'IMAPS',
            995: 'POP3S',
            1433: 'SQL Server',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL',
            5900: 'VNC',
            8080: 'HTTP-Alt'
        }
        
        self.vulnerability_db = {
            21: {
                'service': 'FTP',
                'severity': 'Medium',
                'description': 'FTP transmite credenciales en texto plano',
                'recommendation': 'Usar SFTP o FTPS en su lugar'
            },
            23: {
                'service': 'Telnet',
                'severity': 'High',
                'description': 'Telnet transmite datos sin cifrar',
                'recommendation': 'Migrar a SSH para conexiones seguras'
            },
            135: {
                'service': 'RPC',
                'severity': 'Medium',
                'description': 'RPC puede exponer información del sistema',
                'recommendation': 'Deshabilitar si no es necesario'
            },
            139: {
                'service': 'NetBIOS',
                'severity': 'Medium', 
                'description': 'NetBIOS puede filtrar información de red',
                'recommendation': 'Deshabilitar NetBIOS sobre TCP/IP'
            },
            445: {
                'service': 'SMB',
                'severity': 'High',
                'description': 'SMB v1 es vulnerable a ataques remotos',
                'recommendation': 'Actualizar a SMB v2/v3 y aplicar parches'
            },
            3389: {
                'service': 'RDP',
                'severity': 'High',
                'description': 'RDP expuesto puede ser objetivo de ataques',
                'recommendation': 'Usar VPN o restringir acceso por IP'
            },
            5900: {
                'service': 'VNC',
                'severity': 'High',
                'description': 'VNC puede tener autenticación débil',
                'recommendation': 'Configurar contraseñas fuertes y túnel SSH'
            }
        }
        
        self.scan_results = {}
        self.vulnerability_report = []
        
    def scan_device_ports(self, ip: str, timeout: float = 1.0) -> Dict[int, str]:
        """Escanear puertos comunes en un dispositivo"""
        open_ports = {}
        
        def scan_port(port: int):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    service = self.common_ports.get(port, 'Unknown')
                    open_ports[port] = service
                sock.close()
            except:
                pass
                
        # Escanear puertos en paralelo
        threads = []
        for port in self.common_ports.keys():
            thread = threading.Thread(target=scan_port, args=(port,))
            threads.append(thread)
            thread.start()
            
        # Esperar a que terminen todos los hilos
        for thread in threads:
            thread.join()
            
        return open_ports
    
    def analyze_device_vulnerabilities(self, ip: str, open_ports: Dict[int, str]) -> List[Dict]:
        """Analizar vulnerabilidades basadas en puertos abiertos"""
        vulnerabilities = []
        
        for port, service in open_ports.items():
            if port in self.vulnerability_db:
                vuln_info = self.vulnerability_db[port].copy()
                vuln_info['device_ip'] = ip
                vuln_info['port'] = port
                vuln_info['timestamp'] = datetime.now().isoformat()
                vulnerabilities.append(vuln_info)
                
        return vulnerabilities
    
    def check_default_credentials(self, ip: str, port: int, service: str) -> Optional[Dict]:
        """Verificar credenciales por defecto comunes"""
        default_creds = {
            'SSH': [('admin', 'admin'), ('root', 'root'), ('admin', 'password')],
            'HTTP': [('admin', 'admin'), ('admin', 'password'), ('admin', '')],
            'Telnet': [('admin', 'admin'), ('admin', 'password')],
            'FTP': [('anonymous', ''), ('ftp', 'ftp'), ('admin', 'admin')]
        }
        
        if service in default_creds:
            # Simulación de verificación de credenciales
            # En un entorno real, esto haría conexiones reales
            return {
                'vulnerability': 'Default Credentials',
                'severity': 'Critical',
                'description': f'Posibles credenciales por defecto en {service}',
                'recommendation': 'Cambiar credenciales por defecto inmediatamente'
            }
        return None
    
    def get_device_info(self, ip: str) -> Dict:
        """Obtener información adicional del dispositivo"""
        device_info = {
            'ip': ip,
            'hostname': 'Unknown',
            'os_guess': 'Unknown',
            'mac_address': 'Unknown'
        }
        
        try:
            # Intentar resolver hostname
            hostname = socket.gethostbyaddr(ip)[0]
            device_info['hostname'] = hostname
        except:
            pass
            
        try:
            # Obtener dirección MAC usando ARP
            result = subprocess.run(['arp', '-n', ip], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            device_info['mac_address'] = parts[2]
                        break
        except:
            pass
            
        return device_info
    
    def analyze_network_configuration(self) -> List[Dict]:
        """Analizar configuración de red en busca de problemas de seguridad"""
        network_issues = []
        
        try:
            # Verificar configuración WiFi
            result = subprocess.run(['networksetup', '-getairportnetwork', 'en0'], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                network_name = result.stdout.strip().split(': ')[-1]
                
                # Verificar si la red usa WEP (inseguro)
                wifi_info = subprocess.run(['networksetup', '-getairportpower', 'en0'],
                                         capture_output=True, text=True, timeout=5)
                
                # Análisis básico de seguridad WiFi
                if 'WEP' in network_name.upper():
                    network_issues.append({
                        'vulnerability': 'Weak WiFi Encryption',
                        'severity': 'High',
                        'description': 'La red WiFi usa encriptación WEP obsoleta',
                        'recommendation': 'Actualizar a WPA2/WPA3'
                    })
                    
        except Exception as e:
            pass
            
        return network_issues
    
    def scan_network_devices(self, network_devices: List[str]) -> Dict:
        """Escanear todos los dispositivos de la red en busca de vulnerabilidades"""
        print("🔍 Iniciando escaneo de vulnerabilidades...")
        
        all_vulnerabilities = []
        device_summaries = {}
        
        for device_ip in network_devices:
            print(f"   Analizando {device_ip}...")
            
            # Escanear puertos
            open_ports = self.scan_device_ports(device_ip)
            
            # Obtener información del dispositivo
            device_info = self.get_device_info(device_ip)
            
            # Analizar vulnerabilidades
            device_vulns = self.analyze_device_vulnerabilities(device_ip, open_ports)
            
            # Verificar credenciales por defecto
            for port, service in open_ports.items():
                default_cred_vuln = self.check_default_credentials(device_ip, port, service)
                if default_cred_vuln:
                    default_cred_vuln['device_ip'] = device_ip
                    default_cred_vuln['port'] = port
                    default_cred_vuln['service'] = service
                    device_vulns.append(default_cred_vuln)
            
            # Resumen del dispositivo
            device_summaries[device_ip] = {
                'device_info': device_info,
                'open_ports': open_ports,
                'vulnerabilities': device_vulns,
                'risk_score': self.calculate_risk_score(device_vulns)
            }
            
            all_vulnerabilities.extend(device_vulns)
        
        # Analizar configuración de red
        network_vulns = self.analyze_network_configuration()
        all_vulnerabilities.extend(network_vulns)
        
        # Generar reporte final
        report = {
            'scan_timestamp': datetime.now().isoformat(),
            'total_devices': len(network_devices),
            'total_vulnerabilities': len(all_vulnerabilities),
            'device_summaries': device_summaries,
            'network_vulnerabilities': network_vulns,
            'severity_summary': self.get_severity_summary(all_vulnerabilities)
        }
        
        self.vulnerability_report = report
        print(f"✅ Escaneo completado: {len(all_vulnerabilities)} vulnerabilidades encontradas")
        
        return report
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> int:
        """Calcular puntuación de riesgo basada en vulnerabilidades"""
        score = 0
        severity_points = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }
        
        for vuln in vulnerabilities:
            score += severity_points.get(vuln.get('severity', 'Low'), 1)
            
        return min(score, 100)  # Máximo 100 puntos
    
    def get_severity_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """Obtener resumen de severidad de vulnerabilidades"""
        summary = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            if severity in summary:
                summary[severity] += 1
                
        return summary
    
    def get_top_recommendations(self, limit: int = 5) -> List[str]:
        """Obtener las principales recomendaciones de seguridad"""
        if not self.vulnerability_report:
            return []
            
        recommendations = set()
        vulnerabilities = []
        
        # Recopilar todas las vulnerabilidades
        for device_data in self.vulnerability_report.get('device_summaries', {}).values():
            vulnerabilities.extend(device_data.get('vulnerabilities', []))
        vulnerabilities.extend(self.vulnerability_report.get('network_vulnerabilities', []))
        
        # Ordenar por severidad y obtener recomendaciones únicas
        severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}
        vulnerabilities.sort(key=lambda x: severity_order.get(x.get('severity', 'Low'), 3))
        
        for vuln in vulnerabilities:
            recommendations.add(vuln.get('recommendation', ''))
            if len(recommendations) >= limit:
                break
                
        return list(recommendations)[:limit]